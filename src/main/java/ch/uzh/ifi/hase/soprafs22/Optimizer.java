package ch.uzh.ifi.hase.soprafs22;

import ch.uzh.ifi.hase.soprafs22.constant.Weekday;
import ch.uzh.ifi.hase.soprafs22.entity.*;



/*

import javassist.compiler.ast.Pair;

import java.util.*;


public class Optimizer {


    public int nDays = 0;
    public int nSlots = 0;
    public int nUsers = 0;
    public HashMap<Long, Integer> users;
    public HashMap<String, Integer> events;


    public Schedule[][][] output;
    public Long[][][] base;  // user - day - slot
    public Long[][][] special; // user - day - slot
    public int[][][] requirements; // day - slot - role
    public Long[] capacityOverall; // for each user
    public Long[] capacityDaily; // now specific for each user, could be fixed or specific for user and day
    public String[] roles;

    public IloNumVar[][][][] x; // user - day - slot - role// initialize

    //public HashMap<Long, List<Long>> roles; // for each user list of roles he can do stored as id




    private IloCplex cplex = new IloCplex(); // check

    public String hashCode(int from, int to) {
        return Integer.toString(from) + Integer.toString(to);
    }

    public Optimizer(TeamCalendar calendar ) throws IloException {

        fillOutFields(calendar);
        // Initialize the model. It is important to initialize the variables first!
        addVariables();
        addSpecialRequirementConstraint();
        addCapacityOverallConstraint();
        capacityDailyConstraint();
        requirementConstraint();
        addObjective();
        // Optionally: export the model to a file, so we can check the mathematical
        // program generated by CPLEX
        cplex.exportModel("model.lp");
        solve();
    }

    public void solve() throws IloException {
        cplex.solve();
        for (int i = 0; i < x.length; i++) {
            for (int j = 0; j < x[i].length; j++) {
                for (int k = 0; k < x[i][j].length; k++) {
                    int res = 0;
                    for (int r = 0; r<x[i][j][k].length; r++) {
                        if (cplex.getValue(x[i][j][k][r])>= 0.5){
                            res ++;
                        }
                        this.output[i][j][k].setAssigned(res);

                    }
                }
            }
        }
    }

    // 4-d array of variables
    private void addVariables() throws IloException {
        for (int i = 0; i < base.length; i++) {
            for (int j = 0; j < base[i].length; j++) {
                for (int k = 0; k < base[i][j].length; k++) {
                    for (int r = 0; r<roles.length; r++) {
                        IloNumVar var = cplex.boolVar();
                        x[i][j][k][r] = var;
                    }
                }
            }
        }
    }

   /**
     * Checks whether the current solution to the model is feasible
     *
     * @return the feasibility of the model
     * @throws IloException if something is wrong with CPLEX

    public boolean isFeasible() throws IloException {
        return cplex.isPrimalFeasible();
    }



    private void addObjective() throws IloException {
        // Initialize the objective sum to 0
        IloNumExpr obj = cplex.constant(0);
        for (int i = 0; i < x.length; i++) {
            for (int j = 0; j < x[i].length; j++) {
                for (int k = 0; k < x[i][j].length; k++) {
                    // for each day, slot, user:
                    IloNumExpr expr = cplex.constant(0);
                    for (int r = 0; r< x[i][j][k].length; r ++){
                        IloNumExpr term = x[i][j][k][r];
                        expr = cplex.sum(expr, term);
                    }
                    // Take the product of the decision variable and the base preferences
                    IloNumExpr term = cplex.prod(expr, base[i][j][k]);
                    // Add the term to the current sum
                    obj = cplex.sum(obj, term);
                }
            }
        }
        // Add the obj expression as a maximization objective
        cplex.addMaximize(obj);
    }

    // constraint: special req are satisfied
    private void addSpecialRequirementConstraint() throws IloException {
        for (int i = 0; i < x.length; i++) {
            for (int j = 0; j < x[i].length; j++) {
                for (int k = 0; k < x[i][j].length; k++) {
                    IloNumExpr lhs = cplex.constant(0);
                    for (int r = 0; r < x[i][j][k].length; r++) {
                        IloNumExpr term = x[i][j][k][r];
                        lhs = cplex.sum(lhs,term);
                    }
                    cplex.addEq(lhs, special[i][j][k]);
                }
            }
        }
    }


    private void addCapacityOverallConstraint() throws IloException {
        for (int i = 0; i < x.length; i++) {
            // for each person compute sum of hours working and specify that it is not more than some contant
            IloNumExpr lhs = cplex.constant(0);
            for (int j = 0; j < x[i].length; j++) {
                for (int k = 0; k < x[i][j].length; k++) {
                    for (int r = 0; k < x[i][j][k].length; r++) {
                        IloNumExpr term = x[i][j][k][r];
                        lhs = cplex.sum(lhs, term);
                    }
                }
            }
            cplex.addLe(lhs, capacityOverall[i]);
        }
    }


    private void capacityDailyConstraint() throws IloException {
        // sum across users and roles
        int n_days = x[0].length;
        int n_slottd = x[0][0].length;

        for (int i = 0; i < x.length; i++) {
            // for each person compute sum of hours working and specify that it is not more than some contant
            for (int j = 0; j < x[i].length; j++) {
                IloNumExpr lhs = cplex.constant(0);
                for (int k = 0; k < x[i][j].length; k++) {
                    for (int r = 0; k < x[i][j][k].length; r++) {
                        IloNumExpr term = x[i][j][k][r];
                        lhs = cplex.sum(lhs,  term);
                    }
                }
                cplex.addLe(lhs, capacityOverall[i]);
            }
        }
    }

    private void requirementConstraint() throws IloException {
        // for each day each slot sum of users x which <= requirements for that day, slot
        // for each day
        for (int j = 0; j < requirements.length; j++) {
            // for each slot
            for (int k = 0; k < requirements[j].length; k++) {
                // for each role
                for (int r = 0; r < requirements[j][k].length; r++) {
                    IloNumExpr lhs = cplex.constant(0);
                    for (int i= 0; i< x.length; i++){
                        IloNumExpr term = x[i][j][k][r];
                        lhs = cplex.sum(lhs,  term);
                    }
                    cplex.addLe(lhs, requirements[j][k][r]);

                }
            }
        }
    }

    private void noCollisionConstraint() throws IloException {
        // sum across roles should not be larger than

        for (int i = 0; i < x.length; i++) {
            for (int j = 0; j < x[i].length; j++) {
                for (int k = 0; k < x[i][j].length; k++) {
                    IloNumExpr lhs = cplex.constant(0);
                    for (int r = 0; r < x[i][j][k].length; r++) {
                        IloNumExpr term = x[i][j][k][r];
                        lhs = cplex.sum(lhs, term);
                    }
                    cplex.addLe(lhs, 1);
                }
            }
        }
    }

    //TODO: constraint: everybody does correct role


    public void fillOutFields(TeamCalendar calendar){

        Integer j = 0;
        for (Membership membership:calendar.getTeam().getMemberships()){
            this.users.put(membership.getUser().getId(), j);
            j++;
        }

        Integer s = 0;
        for (Map.Entry<Integer, Day> entry:calendar.getBasePlan().entrySet()){
            for (Event event:entry.getValue().getEvents()){

                if (!this.events.containsKey(hashCode(event.getTimeFrom(), event.getTimeTo()))){
                    events.put(hashCode(event.getTimeFrom(), event.getTimeTo()), s);
                    s++;
                }
            }
        }
        this.nDays = calendar.getBasePlan().size();
        //TODO: finish the roles
        // this.nRoles = calendar.getTeam().getRoles().size();
        this.nUsers = j;
        this.nSlots = s;

        // initialize empty arrays
        this.base = new Long[nUsers][nDays][nSlots];
        this.special = new Long[nUsers][nDays][nSlots];
        this.requirements = new int[nUsers][nDays][nSlots]; // check
        this.capacityDaily = new  Long[nUsers];
        this.capacityOverall = new  Long[nUsers];
        this.roles = new String[1];
        this.roles[0] = "test";

        // fill out the arrays
        int d = -1;
        // for each day
        for (Map.Entry<Weekday, Day> entry:calendar.getBasePlan().entrySet()){
            d++;
            // for each event
            for (Event event:entry.getValue().getEvents()){
                int i = events.get(hashCode(event.getTimeFrom(), event.getTimeTo()));
                // for each user
                for(Schedule schedule: event.getSchedules()){

                    int u = users.get(schedule.getUser().getId());

                    this.output[u][d][i] = schedule;
                    this.base[u][d][i] = schedule.getBasePreference();
                    this.special[u][d][i] = schedule.getSpecialPreference();

                    for (int k = 0; k< roles.length; k++){
                        //this.requirements[d][i][k] = event.getRequirements().get(rolesAll[k]);
                        this.requirements[d][i][k] = 2;
                    }
                }

            }
        }
    }


}
*/